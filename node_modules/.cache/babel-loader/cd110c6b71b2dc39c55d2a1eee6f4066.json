{"ast":null,"code":"// Copyright 2017-2019 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isUndefined } from '@polkadot/util';\n\nfunction sig(_, {\n  method,\n  section\n}, args) {\n  return `${section}.${method}(${args.join(', ')})`;\n}\n\nfunction doDoubleMap(registry, creator, args) {\n  const {\n    key1,\n    key2\n  } = creator.meta.type.asDoubleMap;\n  assert(args.length === 2, () => `${sig(registry, creator, [key1, key2])} is a double map, requiring 2 arguments, ${args.length} found`); // pass as tuple\n\n  return [creator, args];\n}\n\nfunction doMap(registry, creator, args) {\n  const {\n    key\n  } = creator.meta.type.asMap;\n  assert(args.length === 1, () => `${sig(registry, creator, [key])} is a map, requiring 1 argument, ${args.length} found`); // expand\n\n  return args.length ? [creator, args[0]] : [creator];\n}\n\nfunction doNMap(registry, creator, args) {\n  const {\n    keyVec\n  } = creator.meta.type.asNMap;\n  assert(args.length === keyVec.length, () => `${sig(registry, creator, keyVec)} is a multi map, requiring ${keyVec.length} arguments, ${args.length} found`); // pass as tuple\n\n  return [creator, args];\n} // sets up the arguments in the form of [creator, args] ready to be used in a storage\n// call. Additionally, it verifies that the correct number of arguments have been passed\n\n\nexport function extractStorageArgs(registry, creator, _args) {\n  const args = _args.filter(arg => !isUndefined(arg));\n\n  if (creator.meta.type.isDoubleMap) {\n    return doDoubleMap(registry, creator, args);\n  } else if (creator.meta.type.isMap) {\n    return doMap(registry, creator, args);\n  } else if (creator.meta.type.isNMap) {\n    return doNMap(registry, creator, args);\n  }\n\n  assert(args.length === 0, () => `${sig(registry, creator, [])} does not take any arguments, ${args.length} found`); // no args\n\n  return [creator];\n}","map":{"version":3,"sources":["/Users/wangxiaoxu/Documents/project/bchain/substrate-front-end-template/node_modules/@polkadot/api/util/validate.js"],"names":["assert","isUndefined","sig","_","method","section","args","join","doDoubleMap","registry","creator","key1","key2","meta","type","asDoubleMap","length","doMap","key","asMap","doNMap","keyVec","asNMap","extractStorageArgs","_args","filter","arg","isDoubleMap","isMap","isNMap"],"mappings":"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","sourcesContent":["// Copyright 2017-2019 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isUndefined } from '@polkadot/util';\n\nfunction sig(_, {\n  method,\n  section\n}, args) {\n  return `${section}.${method}(${args.join(', ')})`;\n}\n\nfunction doDoubleMap(registry, creator, args) {\n  const {\n    key1,\n    key2\n  } = creator.meta.type.asDoubleMap;\n  assert(args.length === 2, () => `${sig(registry, creator, [key1, key2])} is a double map, requiring 2 arguments, ${args.length} found`); // pass as tuple\n\n  return [creator, args];\n}\n\nfunction doMap(registry, creator, args) {\n  const {\n    key\n  } = creator.meta.type.asMap;\n  assert(args.length === 1, () => `${sig(registry, creator, [key])} is a map, requiring 1 argument, ${args.length} found`); // expand\n\n  return args.length ? [creator, args[0]] : [creator];\n}\n\nfunction doNMap(registry, creator, args) {\n  const {\n    keyVec\n  } = creator.meta.type.asNMap;\n  assert(args.length === keyVec.length, () => `${sig(registry, creator, keyVec)} is a multi map, requiring ${keyVec.length} arguments, ${args.length} found`); // pass as tuple\n\n  return [creator, args];\n} // sets up the arguments in the form of [creator, args] ready to be used in a storage\n// call. Additionally, it verifies that the correct number of arguments have been passed\n\n\nexport function extractStorageArgs(registry, creator, _args) {\n  const args = _args.filter(arg => !isUndefined(arg));\n\n  if (creator.meta.type.isDoubleMap) {\n    return doDoubleMap(registry, creator, args);\n  } else if (creator.meta.type.isMap) {\n    return doMap(registry, creator, args);\n  } else if (creator.meta.type.isNMap) {\n    return doNMap(registry, creator, args);\n  }\n\n  assert(args.length === 0, () => `${sig(registry, creator, [])} does not take any arguments, ${args.length} found`); // no args\n\n  return [creator];\n}"]},"metadata":{},"sourceType":"module"}