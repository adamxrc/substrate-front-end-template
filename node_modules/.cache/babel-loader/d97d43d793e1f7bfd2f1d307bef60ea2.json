{"ast":null,"code":"// Copyright 2019-2021 @polkadot/extension authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { u8aConcat, u8aEq, u8aToU8a } from '@polkadot/util';\nexport const ETHEREUM = u8aToU8a('\\x19Ethereum Signed Message:\\n');\nexport const PREFIX = u8aToU8a('<Bytes>');\nexport const POSTFIX = u8aToU8a('</Bytes>');\nconst WRAP_LEN = PREFIX.length + POSTFIX.length;\n\nfunction isWrapped(u8a, withEthereum) {\n  return u8a.length >= WRAP_LEN && u8aEq(u8a.subarray(0, PREFIX.length), PREFIX) && u8aEq(u8a.slice(-POSTFIX.length), POSTFIX) || withEthereum && u8a.length >= ETHEREUM.length && u8aEq(u8a.subarray(0, ETHEREUM.length), ETHEREUM);\n}\n\nexport function unwrapBytes(bytes) {\n  const u8a = u8aToU8a(bytes); // we don't want to unwrap Ethereum-style wraps\n\n  return isWrapped(u8a, false) ? u8a.subarray(PREFIX.length, u8a.length - POSTFIX.length) : u8a;\n}\nexport function wrapBytes(bytes) {\n  const u8a = u8aToU8a(bytes); // if Ethereum-wrapping, we don't add our wrapping bytes\n\n  return isWrapped(u8a, true) ? u8a : u8aConcat(PREFIX, u8a, POSTFIX);\n}","map":{"version":3,"sources":["/Users/wangxiaoxu/Documents/project/bchain/substrate-front-end-template/node_modules/@polkadot/extension-dapp/wrapBytes.js"],"names":["u8aConcat","u8aEq","u8aToU8a","ETHEREUM","PREFIX","POSTFIX","WRAP_LEN","length","isWrapped","u8a","withEthereum","subarray","slice","unwrapBytes","bytes","wrapBytes"],"mappings":"AAAA;AACA;AACA,SAASA,SAAT,EAAoBC,KAApB,EAA2BC,QAA3B,QAA2C,gBAA3C;AACA,OAAO,MAAMC,QAAQ,GAAGD,QAAQ,CAAC,gCAAD,CAAzB;AACP,OAAO,MAAME,MAAM,GAAGF,QAAQ,CAAC,SAAD,CAAvB;AACP,OAAO,MAAMG,OAAO,GAAGH,QAAQ,CAAC,UAAD,CAAxB;AACP,MAAMI,QAAQ,GAAGF,MAAM,CAACG,MAAP,GAAgBF,OAAO,CAACE,MAAzC;;AAEA,SAASC,SAAT,CAAmBC,GAAnB,EAAwBC,YAAxB,EAAsC;AACpC,SAAOD,GAAG,CAACF,MAAJ,IAAcD,QAAd,IAA0BL,KAAK,CAACQ,GAAG,CAACE,QAAJ,CAAa,CAAb,EAAgBP,MAAM,CAACG,MAAvB,CAAD,EAAiCH,MAAjC,CAA/B,IAA2EH,KAAK,CAACQ,GAAG,CAACG,KAAJ,CAAU,CAACP,OAAO,CAACE,MAAnB,CAAD,EAA6BF,OAA7B,CAAhF,IAAyHK,YAAY,IAAID,GAAG,CAACF,MAAJ,IAAcJ,QAAQ,CAACI,MAAvC,IAAiDN,KAAK,CAACQ,GAAG,CAACE,QAAJ,CAAa,CAAb,EAAgBR,QAAQ,CAACI,MAAzB,CAAD,EAAmCJ,QAAnC,CAAtL;AACD;;AAED,OAAO,SAASU,WAAT,CAAqBC,KAArB,EAA4B;AACjC,QAAML,GAAG,GAAGP,QAAQ,CAACY,KAAD,CAApB,CADiC,CACJ;;AAE7B,SAAON,SAAS,CAACC,GAAD,EAAM,KAAN,CAAT,GAAwBA,GAAG,CAACE,QAAJ,CAAaP,MAAM,CAACG,MAApB,EAA4BE,GAAG,CAACF,MAAJ,GAAaF,OAAO,CAACE,MAAjD,CAAxB,GAAmFE,GAA1F;AACD;AACD,OAAO,SAASM,SAAT,CAAmBD,KAAnB,EAA0B;AAC/B,QAAML,GAAG,GAAGP,QAAQ,CAACY,KAAD,CAApB,CAD+B,CACF;;AAE7B,SAAON,SAAS,CAACC,GAAD,EAAM,IAAN,CAAT,GAAuBA,GAAvB,GAA6BT,SAAS,CAACI,MAAD,EAASK,GAAT,EAAcJ,OAAd,CAA7C;AACD","sourcesContent":["// Copyright 2019-2021 @polkadot/extension authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { u8aConcat, u8aEq, u8aToU8a } from '@polkadot/util';\nexport const ETHEREUM = u8aToU8a('\\x19Ethereum Signed Message:\\n');\nexport const PREFIX = u8aToU8a('<Bytes>');\nexport const POSTFIX = u8aToU8a('</Bytes>');\nconst WRAP_LEN = PREFIX.length + POSTFIX.length;\n\nfunction isWrapped(u8a, withEthereum) {\n  return u8a.length >= WRAP_LEN && u8aEq(u8a.subarray(0, PREFIX.length), PREFIX) && u8aEq(u8a.slice(-POSTFIX.length), POSTFIX) || withEthereum && u8a.length >= ETHEREUM.length && u8aEq(u8a.subarray(0, ETHEREUM.length), ETHEREUM);\n}\n\nexport function unwrapBytes(bytes) {\n  const u8a = u8aToU8a(bytes); // we don't want to unwrap Ethereum-style wraps\n\n  return isWrapped(u8a, false) ? u8a.subarray(PREFIX.length, u8a.length - POSTFIX.length) : u8a;\n}\nexport function wrapBytes(bytes) {\n  const u8a = u8aToU8a(bytes); // if Ethereum-wrapping, we don't add our wrapping bytes\n\n  return isWrapped(u8a, true) ? u8a : u8aConcat(PREFIX, u8a, POSTFIX);\n}"]},"metadata":{},"sourceType":"module"}